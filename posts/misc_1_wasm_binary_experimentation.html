<!DOCTYPE html><html><head><title>Ubaid Shaikh</title><meta name="description" content="This is Ubaid Shaikh&#x27;s portfolio Website"/><link rel="icon" href="/favicon.ico"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta charSet="UTF-8"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/63637aae99d8f3d6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/63637aae99d8f3d6.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/_next/static/chunks/webpack-b8f8d6679aaa5f42.js" defer=""></script><script src="/_next/static/chunks/framework-7751730b10fa0f74.js" defer=""></script><script src="/_next/static/chunks/main-e7a7892cb0edc024.js" defer=""></script><script src="/_next/static/chunks/pages/_app-70174acae681883c.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-8d0d04d2d87907dd.js" defer=""></script><script src="/_next/static/2ii59PcnJFayGOASnop7S/_buildManifest.js" defer=""></script><script src="/_next/static/2ii59PcnJFayGOASnop7S/_ssgManifest.js" defer=""></script></head><body><div id="__next"><div><div class="navbar bg-base-100"><div class="navbar-start"><div class="dropdown"><label tabindex="0" class="btn btn-ghost lg:hidden"><svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h8m-8 6h16"></path></svg></label><ul tabindex="0" class="menu menu-compact dropdown-content mt-3 p-2 shadow bg-base-100 rounded-box w-52"><li><a href="/posts">Posts</a></li><li><a href="/contact">Contact</a></li></ul></div><span class="btn btn-ghost normal-case"><img src="/ubaid_shaikh_logo.svg" alt="logo" height="100%" width="200"/></span></div><div class="navbar-end hidden lg:flex"><ul class="menu menu-horizontal p-0"><li><a href="/posts">Posts</a></li><li><a href="/contact">Contact</a></li></ul></div></div><div class="flex place-content-center"><div class="w-4/5"><br/><div class="link"><i class="ri-arrow-left-line"></i> Back to posts</div><br/><article class="prose prose-lg md:prose-xl"><h1>Wasm Binary Internals Demystified</h1><h3>Let us write a script which writes wasm ...</h3><div class="flex justify-between"><div><i class="ri-calendar-2-line"></i> <!-- -->May 1, 2022</div><div><i class="ri-time-line"></i> <!-- -->9 min read</div></div></article><hr class="mt-5 mb-8"/><div class="w-3/4 w-full m-auto"><article class="prose prose-base"><div class="blog-content md:text-lg"><h1 id="wasm-binary-experimentation">WASM Binary Experimentation</h1>
<p>In this notebook, let us write a <code>python</code> script which writes <code>wasm</code>
binary. (Yup, you read it right, writing a script that writes another
script, ðŸ˜Ž)</p>
<p>For example, let us aim to write the following <code>WAT</code> in <code>wasm</code> binary
using our <code>python</code> script.</p>
<pre><code>(module
  (func (export "get_const_val") (result i32)
    i32.const -10)
  (func (export "add_two_nums") (param i32 i32) (result i32)
    local.get 0
    local.get 1
    i32.add)
  (func (export "call_functions") (result i32)
    call 0
    call 0
    call 1)
)
</code></pre>
<ul>
<li>The function <code>get_const_val</code> returns a constant value of <code>-10</code>.</li>
<li>The function <code>add_two_nums</code> adds the given numbers and returns the
result of addition.</li>
<li>The function <code>call_functions</code> calls <code>get_const_val</code> twice and then
calls <code>add_two_nums</code>. Please note here that we used the indexes of
the <code>get_const_val</code> and <code>add_two_nums</code> when calling them.</li>
</ul>
<p>In python, the implementation of these functions would be as follows:</p>
<pre><code class="hljs language-python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_const_val</span>():
  <span class="hljs-keyword">return</span> -<span class="hljs-number">10</span>

<span class="hljs-keyword">def</span> <span class="hljs-title function_">add_two_nums</span>(<span class="hljs-params">a, b</span>): <span class="hljs-comment"># in the WAT format, we did not give names, instead we used indexes to refer to the parameters</span>
  <span class="hljs-keyword">return</span> a + b

<span class="hljs-keyword">def</span> <span class="hljs-title function_">call_functions</span>():
  <span class="hljs-keyword">return</span> add_two_nums(get_const_val(), get_const_val())
</code></pre>
<p>Our <code>python</code> script starts from the following sections.</p>
<p><strong>Let's dive in!!!</strong></p>
<h2 id="importing-required-modules">Importing required modules</h2>
<p><code>wasm</code> expects integers to be in <code>leb128</code> (Little Endian Base 128)
format. So, we use the following library/module to encode the <code>integers</code>
(<code>signed</code> as well as <code>unsigned</code>). Also, from my experience, <code>index</code> of
variables/functions are being considered to be <code>integers</code> and therefore
need to be encoded.</p>
<pre><code class="hljs language-python">!pip install leb128
<span class="hljs-keyword">import</span> leb128
</code></pre>
<pre><code>Requirement already satisfied: leb128 in /usr/local/lib/python3.7/dist-packages (1.0.4)
</code></pre>
<p>To test the generated <code>test.wasm</code> we need to import the <code>wasm</code> exported
functions in <code>JavaScript</code>/<code>node.js</code>. Since, it seems that <code>Google Colab</code>
supports only <code>client</code> side <code>JavaScript</code> and does not support <code>node.js</code>,
here, we can currently (temporarily) use <code>pywasm</code> (which provides the
<code>WebAssembly</code> runtime for <code>python</code>) to test the exported function.</p>
<pre><code class="hljs language-python">!pip install pywasm
<span class="hljs-keyword">import</span> pywasm
</code></pre>
<pre><code>Requirement already satisfied: pywasm in /usr/local/lib/python3.7/dist-packages (1.0.7)
Requirement already satisfied: numpy in /usr/local/lib/python3.7/dist-packages (from pywasm) (1.21.6)
</code></pre>
<h2 id="generating-the-testwasm-binary">Generating the <code>test.wasm</code> binary</h2>
<p>A <code>wasm</code> binary starts with <code>module</code> and <code>version</code></p>
<p>here:</p>
<ul>
<li><code>module</code> = "\0asm"</li>
<li><code>version</code> = 1</li>
</ul>
<pre><code class="hljs language-python">module = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x00</span>, <span class="hljs-number">0x61</span>, <span class="hljs-number">0x73</span>, <span class="hljs-number">0x6d</span>])
version = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x01</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>, <span class="hljs-number">0x00</span>])
</code></pre>
<p><code>wasm</code> binary consists of the following sections. These sections come
after the <code>mdoule</code> and <code>version</code>.</p>
<p>  Id   Section</p>
<hr>
<p>  0    custom section
  1    type section
  2    import section
  3    function section
  4    table section
  5    memory section
  6    global section
  7    export section
  8    start section
  9    element section
  10   code section
  11   data section
  12   data count section</p>
<p>Each section consists of</p>
<ul>
<li>a one-byte section id,</li>
<li>the size of the contents, in bytes,</li>
<li>the actual contents, whose structure is depended on the section id.</li>
</ul>
<p>These sections can either be omitted or can be present atmost once.
Also, these sections need to be present in the specific order.</p>
<p>Let us define the sections we need in the following cells.</p>
<h3 id="type-section">Type Section</h3>
<p>From my understanding, this section is used to declare <code>function type</code>
that is <code>function signature</code> (I assume this to be similar to
<code>function declaration</code> or <code>function prototyping</code> in <code>C</code>/<code>C++</code>)</p>
<p>Let's define the functions types for our three functions
(<code>get_const_val</code>, <code>add_two_nums</code>, <code>call_functions</code>) one by one</p>
<pre><code class="hljs language-python">param_types_get_const_val = <span class="hljs-built_in">bytearray</span>([]) <span class="hljs-comment"># its parameter list is empty</span>
param_types_get_const_val = leb128.u.encode(<span class="hljs-built_in">len</span>(param_types_get_const_val)) + param_types_get_const_val <span class="hljs-comment"># prepend length (in encoded form) of the list to itself</span>

return_types_get_const_val = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x7f</span>]) <span class="hljs-comment"># its return list is just integer</span>
return_types_get_const_val = leb128.u.encode(<span class="hljs-built_in">len</span>(return_types_get_const_val)) + return_types_get_const_val <span class="hljs-comment"># prepend length (in encoded form) of the list to itself</span>

func_type_get_const_val = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x60</span>]) + param_types_get_const_val + return_types_get_const_val
</code></pre>
<pre><code class="hljs language-python">param_types_add_two_nums = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x7f</span>, <span class="hljs-number">0x7f</span>]) <span class="hljs-comment"># its parameter list is two integers</span>
param_types_add_two_nums = leb128.u.encode(<span class="hljs-built_in">len</span>(param_types_add_two_nums)) + param_types_add_two_nums <span class="hljs-comment"># prepend length (in encoded form) of the list to itself</span>

return_types_add_two_nums = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x7f</span>]) <span class="hljs-comment"># its return list is just integer</span>
return_types_add_two_nums = leb128.u.encode(<span class="hljs-built_in">len</span>(return_types_add_two_nums)) + return_types_add_two_nums <span class="hljs-comment"># prepend length (in encoded form) of the list to itself</span>

func_type_add_two_nums = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x60</span>]) + param_types_add_two_nums + return_types_add_two_nums
</code></pre>
<pre><code class="hljs language-python">param_types_call_functions = <span class="hljs-built_in">bytearray</span>([]) <span class="hljs-comment"># its parameter list is empty</span>
param_types_call_functions = leb128.u.encode(<span class="hljs-built_in">len</span>(param_types_call_functions)) + param_types_call_functions <span class="hljs-comment"># prepend length (in encoded form) of the list to itself</span>

return_types_call_functions = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x7f</span>]) <span class="hljs-comment"># its return list is just integer</span>
return_types_call_functions = leb128.u.encode(<span class="hljs-built_in">len</span>(return_types_call_functions)) + return_types_call_functions <span class="hljs-comment"># prepend length (in encoded form) of the list to itself</span>

func_type_call_functions = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x60</span>]) + param_types_call_functions + return_types_call_functions
</code></pre>
<p>Let us now define our <code>type</code> section</p>
<pre><code class="hljs language-python">func_types = [func_type_get_const_val, func_type_add_two_nums, func_type_call_functions] <span class="hljs-comment"># take care to add these functions in proper order, as we will use indexes to refer them</span>

type_section_id = leb128.u.encode(<span class="hljs-number">1</span>) <span class="hljs-comment"># id of type section is 1</span>

type_section_content = leb128.u.encode(
    <span class="hljs-built_in">len</span>(func_types))  <span class="hljs-comment"># first add length (in encoded form) and then</span>
<span class="hljs-keyword">for</span> func_type <span class="hljs-keyword">in</span> func_types: <span class="hljs-comment"># add the contents of func_types</span>
    type_section_content.extend(func_type)
</code></pre>
<pre><code class="hljs language-python">type_section = type_section_id + leb128.u.encode(<span class="hljs-built_in">len</span>(type_section_content)) + type_section_content
</code></pre>
<h3 id="function-section">Function Section</h3>
<p>So, from the section name, it seems we will be defining our <code>functions</code>
in this section. From my understanding, we need to break our function
definition into parts, the function prototype and the function body.
(Yup, I know we already declared our function prototypes in the <code>type</code>
section)</p>
<p>Here, instead of redeclaring our <code>function types</code> (or
<code>function prototypes</code> as I understand them), we will reference the
already defined <code>function type</code>. That is we will just specify an index
to the <code>function type</code> that we wish to have for our <code>function</code>.</p>
<p>The next question that comes here is that</p>
<ul>
<li>ok, I referenced the <code>function type</code> (lets say) at index <code>0</code>, where
do I write its <code>function body</code>?</li>
</ul>
<p><code>ans:</code> As per the <a href="https://webassembly.github.io/spec/core/binary/modules.html#binary-codesec">WebAssembly
Docs</a>,
it happens that, <code>function bodies</code> (<code>local variables</code> + <code>statements</code> are
to be mentioned in the <code>code section</code>).</p>
<p>So, let's go ahead and reference the three declared <code>function types</code></p>
<pre><code class="hljs language-python">type_ids = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])

func_section_id = leb128.u.encode(<span class="hljs-number">3</span>)  <span class="hljs-comment"># id of function section is 3</span>
func_section_content = leb128.u.encode(
    <span class="hljs-built_in">len</span>(type_ids)) <span class="hljs-comment"># first add length (in encoded form) and then</span>
func_section_content += type_ids <span class="hljs-comment"># add the contents of type_ids</span>
</code></pre>
<pre><code class="hljs language-python">func_section = func_section_id + leb128.u.encode(<span class="hljs-built_in">len</span>(func_section_content)) + func_section_content
</code></pre>
<h3 id="code-section">Code Section</h3>
<p>We define our <code>function bodies</code> (<code>local variables</code> + <code>statements</code>) for
our three functions (<code>get_const_val</code>, <code>add_two_nums</code>, <code>call_functions</code>)
in this section.</p>
<pre><code class="hljs language-python">local_vars_get_const_val = <span class="hljs-built_in">bytearray</span>([]) <span class="hljs-comment"># it does not contain any local variables</span>
local_vars_get_const_val = leb128.u.encode(<span class="hljs-built_in">len</span>(local_vars_get_const_val)) + local_vars_get_const_val

instructions_get_const_val_1 = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x41</span>]) + leb128.i.encode(-<span class="hljs-number">10</span>) <span class="hljs-comment"># it contains just one instruction</span>

expr_get_const_val = instructions_get_const_val_1 + <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x0b</span>]) <span class="hljs-comment"># expression contains all instructions and it ends with byte 0x0b</span>

func_get_const_val = local_vars_get_const_val + expr_get_const_val

code_get_const_val = leb128.u.encode(<span class="hljs-built_in">len</span>(func_get_const_val)) + func_get_const_val
</code></pre>
<pre><code class="hljs language-python">local_vars_add_two_nums = <span class="hljs-built_in">bytearray</span>([]) <span class="hljs-comment"># it does not contain any local variables</span>
local_vars_add_two_nums = leb128.u.encode(<span class="hljs-built_in">len</span>(local_vars_add_two_nums)) + local_vars_add_two_nums

instructions_add_two_nums_1 = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x20</span>]) + leb128.u.encode(<span class="hljs-number">0</span>) <span class="hljs-comment"># get parameter 0</span>
instructions_add_two_nums_2 = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x20</span>]) + leb128.u.encode(<span class="hljs-number">1</span>) <span class="hljs-comment"># get parameter 1</span>
instructions_add_two_nums_3 = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x6a</span>]) <span class="hljs-comment"># add the two operands on the stack</span>

expr_add_two_nums = instructions_add_two_nums_1 + instructions_add_two_nums_2 + instructions_add_two_nums_3 + <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x0b</span>]) <span class="hljs-comment"># expression contains all instructions and it ends with byte 0x0b</span>

func_add_two_nums = local_vars_add_two_nums + expr_add_two_nums

code_add_two_nums = leb128.u.encode(<span class="hljs-built_in">len</span>(func_add_two_nums)) + func_add_two_nums
</code></pre>
<pre><code class="hljs language-python">local_vars_call_functions = <span class="hljs-built_in">bytearray</span>([]) <span class="hljs-comment"># it does not contain any local variables</span>
local_vars_call_functions = leb128.u.encode(<span class="hljs-built_in">len</span>(local_vars_call_functions)) + local_vars_call_functions

instructions_call_functions_1 = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x10</span>]) + leb128.u.encode(<span class="hljs-number">0</span>) <span class="hljs-comment"># call function get_const_val</span>
instructions_call_functions_2 = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x10</span>]) + leb128.u.encode(<span class="hljs-number">0</span>) <span class="hljs-comment"># call function get_const_val</span>
instructions_call_functions_3 = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x10</span>]) + leb128.u.encode(<span class="hljs-number">1</span>) <span class="hljs-comment"># call function call_functions and pass the two values on the stack, that is (-10, -10)</span>

expr_call_functions = instructions_call_functions_1 + instructions_call_functions_2 + instructions_call_functions_3 + <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x0b</span>]) <span class="hljs-comment"># expression contains all instructions and it ends with byte 0x0b</span>

func_call_functions = local_vars_call_functions + expr_call_functions

code_call_functions = leb128.u.encode(<span class="hljs-built_in">len</span>(func_call_functions)) + func_call_functions
</code></pre>
<pre><code class="hljs language-python">codes = [code_get_const_val, code_add_two_nums, code_call_functions]

code_section_id = leb128.u.encode(<span class="hljs-number">10</span>) <span class="hljs-comment"># id of code section is 10</span>
code_section_content = leb128.u.encode(<span class="hljs-built_in">len</span>(codes)) <span class="hljs-comment"># first add length (in encoded form) and then</span>
<span class="hljs-keyword">for</span> code <span class="hljs-keyword">in</span> codes: <span class="hljs-comment"># add the contents of codes</span>
    code_section_content.extend(code)
</code></pre>
<pre><code class="hljs language-python">code_section = code_section_id + leb128.u.encode(<span class="hljs-built_in">len</span>(code_section_content)) + code_section_content
</code></pre>
<p>Please, note here that, the number of <code>types referenced</code> and the number
of <code>function bodies</code> defined must match.</p>
<h3 id="export-section">Export Section</h3>
<p>Now, we need to export our three functions (<code>get_const_val</code>,
<code>add_two_nums</code>, <code>call_functions</code>), so that we can use them in
<code>JavaScript</code></p>
<pre><code class="hljs language-python">name_get_const_val = <span class="hljs-string">"get_const_val"</span>.encode(encoding=<span class="hljs-string">"utf-8"</span>)
name_get_const_val = leb128.u.encode(<span class="hljs-built_in">len</span>(name_get_const_val)) + <span class="hljs-built_in">bytearray</span>(name_get_const_val) <span class="hljs-comment"># add length (in encoded form) followed by the encoded name string</span>

export_desc_get_const_val = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x00</span>]) + leb128.u.encode(<span class="hljs-number">0</span>)  <span class="hljs-comment"># encoding function index</span>

export_get_const_val = name_get_const_val + export_desc_get_const_val
</code></pre>
<pre><code class="hljs language-python">name_add_two_nums = <span class="hljs-string">"add_two_nums"</span>.encode(encoding=<span class="hljs-string">"utf-8"</span>)
name_add_two_nums = leb128.u.encode(<span class="hljs-built_in">len</span>(name_add_two_nums)) + <span class="hljs-built_in">bytearray</span>(name_add_two_nums) <span class="hljs-comment"># add length (in encoded form) followed by the encoded name string</span>

export_desc_add_two_nums = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x00</span>]) + leb128.u.encode(<span class="hljs-number">1</span>)  <span class="hljs-comment"># encoding function index</span>

export_add_two_nums = name_add_two_nums + export_desc_add_two_nums
</code></pre>
<pre><code class="hljs language-python">name_call_functions = <span class="hljs-string">"call_functions"</span>.encode(encoding=<span class="hljs-string">"utf-8"</span>)
name_call_functions = leb128.u.encode(<span class="hljs-built_in">len</span>(name_call_functions)) + <span class="hljs-built_in">bytearray</span>(name_call_functions) <span class="hljs-comment"># add length (in encoded form) followed by the encoded name string</span>

export_desc_call_functions = <span class="hljs-built_in">bytearray</span>([<span class="hljs-number">0x00</span>]) + leb128.u.encode(<span class="hljs-number">2</span>)  <span class="hljs-comment"># encoding function index</span>

export_call_functions = name_call_functions + export_desc_call_functions
</code></pre>
<pre><code class="hljs language-python">exports = [export_get_const_val, export_add_two_nums, export_call_functions]

export_section_id = leb128.u.encode(<span class="hljs-number">7</span>) <span class="hljs-comment"># id of export section is 10</span>
export_section_content = leb128.u.encode(
    <span class="hljs-built_in">len</span>(exports)) <span class="hljs-comment"># first add length (in encoded form) and then</span>
<span class="hljs-keyword">for</span> export <span class="hljs-keyword">in</span> exports: <span class="hljs-comment"># add the contents of exports</span>
    export_section_content.extend(export)
</code></pre>
<pre><code class="hljs language-python">export_section = export_section_id + leb128.u.encode(<span class="hljs-built_in">len</span>(export_section_content)) + export_section_content
</code></pre>
<h2 id="creating-the-final-testwasm">Creating the final <code>test.wasm</code></h2>
<p>We combine all the above sections in the increasing order of section
Ids. Incorrect order leads to inconsitent wasm module.</p>
<pre><code class="hljs language-python">all_code = module + version + type_section + func_section + export_section + code_section
</code></pre>
<p>Now, we write our <code>all_code</code> to <code>binary file</code></p>
<pre><code class="hljs language-python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">"test.wasm"</span>, <span class="hljs-string">"wb"</span>) <span class="hljs-keyword">as</span> wasm_file:
    wasm_file.write(<span class="hljs-built_in">bytes</span>(all_code))
</code></pre>
<h1 id="testing-time">Testing Time!</h1>
<p>Let use first test our functions defined in <code>python</code></p>
<pre><code class="hljs language-python"><span class="hljs-built_in">print</span>(get_const_val())
<span class="hljs-built_in">print</span>(add_two_nums(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>))
<span class="hljs-built_in">print</span>(call_functions())
</code></pre>
<pre><code>-10
9
-20
</code></pre>
<p>Now, to test our <code>wasm</code> functions, we need to import them in
<code>JavaScript</code> and the call them (the code for the same in given in
<code>Appendix</code> at the end). Since, it seems that Google Colab supports only
client side JavaScript and does not support node.js, here, we can
currently (temporarily) use pywasm (which provides the WebAssembly
runtime for python) to test the exported function.</p>
<pre><code class="hljs language-python">runtime = pywasm.load(<span class="hljs-string">'./test.wasm'</span>)
</code></pre>
<pre><code class="hljs language-python"><span class="hljs-built_in">print</span>(runtime.<span class="hljs-built_in">exec</span>(<span class="hljs-string">'get_const_val'</span>, []))
<span class="hljs-built_in">print</span>(runtime.<span class="hljs-built_in">exec</span>(<span class="hljs-string">'add_two_nums'</span>, [<span class="hljs-number">5</span>, <span class="hljs-number">4</span>]))
<span class="hljs-built_in">print</span>(runtime.<span class="hljs-built_in">exec</span>(<span class="hljs-string">'call_functions'</span>, []))
</code></pre>
<pre><code>-10
9
-20
</code></pre>
<h2 id="appendix">Appendix</h2>
<pre><code class="hljs language-javascript"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">'fs'</span>);

<span class="hljs-keyword">const</span> wasmBuffer = fs.<span class="hljs-title function_">readFileSync</span>(<span class="hljs-string">'./test.wasm'</span>);

<span class="hljs-title class_">WebAssembly</span>.<span class="hljs-title function_">instantiate</span>(wasmBuffer).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">wasmModule</span> =&gt;</span> {
    <span class="hljs-comment">// Exported function live under instance.exports</span>
    <span class="hljs-keyword">const</span> get_const_val = wasmModule.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">get_const_val</span>;
    <span class="hljs-keyword">const</span> add_two_nums = wasmModule.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">add_two_nums</span>;
    <span class="hljs-keyword">const</span> call_functions = wasmModule.<span class="hljs-property">instance</span>.<span class="hljs-property">exports</span>.<span class="hljs-property">call_functions</span>;
    
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">get_const_val</span>());
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add_two_nums</span>(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>));
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">call_functions</span>())
});
</code></pre>
</div></article></div></div></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"blog":{"content":"\u003ch1 id=\"wasm-binary-experimentation\"\u003eWASM Binary Experimentation\u003c/h1\u003e\n\u003cp\u003eIn this notebook, let us write a \u003ccode\u003epython\u003c/code\u003e script which writes \u003ccode\u003ewasm\u003c/code\u003e\nbinary. (Yup, you read it right, writing a script that writes another\nscript, ðŸ˜Ž)\u003c/p\u003e\n\u003cp\u003eFor example, let us aim to write the following \u003ccode\u003eWAT\u003c/code\u003e in \u003ccode\u003ewasm\u003c/code\u003e binary\nusing our \u003ccode\u003epython\u003c/code\u003e script.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e(module\n  (func (export \"get_const_val\") (result i32)\n    i32.const -10)\n  (func (export \"add_two_nums\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    i32.add)\n  (func (export \"call_functions\") (result i32)\n    call 0\n    call 0\n    call 1)\n)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eThe function \u003ccode\u003eget_const_val\u003c/code\u003e returns a constant value of \u003ccode\u003e-10\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eThe function \u003ccode\u003eadd_two_nums\u003c/code\u003e adds the given numbers and returns the\nresult of addition.\u003c/li\u003e\n\u003cli\u003eThe function \u003ccode\u003ecall_functions\u003c/code\u003e calls \u003ccode\u003eget_const_val\u003c/code\u003e twice and then\ncalls \u003ccode\u003eadd_two_nums\u003c/code\u003e. Please note here that we used the indexes of\nthe \u003ccode\u003eget_const_val\u003c/code\u003e and \u003ccode\u003eadd_two_nums\u003c/code\u003e when calling them.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIn python, the implementation of these functions would be as follows:\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eget_const_val\u003c/span\u003e():\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e -\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eadd_two_nums\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea, b\u003c/span\u003e): \u003cspan class=\"hljs-comment\"\u003e# in the WAT format, we did not give names, instead we used indexes to refer to the parameters\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e a + b\n\n\u003cspan class=\"hljs-keyword\"\u003edef\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ecall_functions\u003c/span\u003e():\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e add_two_nums(get_const_val(), get_const_val())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eOur \u003ccode\u003epython\u003c/code\u003e script starts from the following sections.\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eLet's dive in!!!\u003c/strong\u003e\u003c/p\u003e\n\u003ch2 id=\"importing-required-modules\"\u003eImporting required modules\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ewasm\u003c/code\u003e expects integers to be in \u003ccode\u003eleb128\u003c/code\u003e (Little Endian Base 128)\nformat. So, we use the following library/module to encode the \u003ccode\u003eintegers\u003c/code\u003e\n(\u003ccode\u003esigned\u003c/code\u003e as well as \u003ccode\u003eunsigned\u003c/code\u003e). Also, from my experience, \u003ccode\u003eindex\u003c/code\u003e of\nvariables/functions are being considered to be \u003ccode\u003eintegers\u003c/code\u003e and therefore\nneed to be encoded.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e!pip install leb128\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e leb128\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eRequirement already satisfied: leb128 in /usr/local/lib/python3.7/dist-packages (1.0.4)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eTo test the generated \u003ccode\u003etest.wasm\u003c/code\u003e we need to import the \u003ccode\u003ewasm\u003c/code\u003e exported\nfunctions in \u003ccode\u003eJavaScript\u003c/code\u003e/\u003ccode\u003enode.js\u003c/code\u003e. Since, it seems that \u003ccode\u003eGoogle Colab\u003c/code\u003e\nsupports only \u003ccode\u003eclient\u003c/code\u003e side \u003ccode\u003eJavaScript\u003c/code\u003e and does not support \u003ccode\u003enode.js\u003c/code\u003e,\nhere, we can currently (temporarily) use \u003ccode\u003epywasm\u003c/code\u003e (which provides the\n\u003ccode\u003eWebAssembly\u003c/code\u003e runtime for \u003ccode\u003epython\u003c/code\u003e) to test the exported function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e!pip install pywasm\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e pywasm\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003eRequirement already satisfied: pywasm in /usr/local/lib/python3.7/dist-packages (1.0.7)\nRequirement already satisfied: numpy in /usr/local/lib/python3.7/dist-packages (from pywasm) (1.21.6)\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"generating-the-testwasm-binary\"\u003eGenerating the \u003ccode\u003etest.wasm\u003c/code\u003e binary\u003c/h2\u003e\n\u003cp\u003eA \u003ccode\u003ewasm\u003c/code\u003e binary starts with \u003ccode\u003emodule\u003c/code\u003e and \u003ccode\u003eversion\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003ehere:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emodule\u003c/code\u003e = \"\\0asm\"\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eversion\u003c/code\u003e = 1\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003emodule = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x00\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0x61\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0x73\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0x6d\u003c/span\u003e])\nversion = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x01\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0x00\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0x00\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0x00\u003c/span\u003e])\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ewasm\u003c/code\u003e binary consists of the following sections. These sections come\nafter the \u003ccode\u003emdoule\u003c/code\u003e and \u003ccode\u003eversion\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003e  Id   Section\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e  0    custom section\n  1    type section\n  2    import section\n  3    function section\n  4    table section\n  5    memory section\n  6    global section\n  7    export section\n  8    start section\n  9    element section\n  10   code section\n  11   data section\n  12   data count section\u003c/p\u003e\n\u003cp\u003eEach section consists of\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ea one-byte section id,\u003c/li\u003e\n\u003cli\u003ethe size of the contents, in bytes,\u003c/li\u003e\n\u003cli\u003ethe actual contents, whose structure is depended on the section id.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThese sections can either be omitted or can be present atmost once.\nAlso, these sections need to be present in the specific order.\u003c/p\u003e\n\u003cp\u003eLet us define the sections we need in the following cells.\u003c/p\u003e\n\u003ch3 id=\"type-section\"\u003eType Section\u003c/h3\u003e\n\u003cp\u003eFrom my understanding, this section is used to declare \u003ccode\u003efunction type\u003c/code\u003e\nthat is \u003ccode\u003efunction signature\u003c/code\u003e (I assume this to be similar to\n\u003ccode\u003efunction declaration\u003c/code\u003e or \u003ccode\u003efunction prototyping\u003c/code\u003e in \u003ccode\u003eC\u003c/code\u003e/\u003ccode\u003eC++\u003c/code\u003e)\u003c/p\u003e\n\u003cp\u003eLet's define the functions types for our three functions\n(\u003ccode\u003eget_const_val\u003c/code\u003e, \u003ccode\u003eadd_two_nums\u003c/code\u003e, \u003ccode\u003ecall_functions\u003c/code\u003e) one by one\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eparam_types_get_const_val = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([]) \u003cspan class=\"hljs-comment\"\u003e# its parameter list is empty\u003c/span\u003e\nparam_types_get_const_val = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(param_types_get_const_val)) + param_types_get_const_val \u003cspan class=\"hljs-comment\"\u003e# prepend length (in encoded form) of the list to itself\u003c/span\u003e\n\nreturn_types_get_const_val = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x7f\u003c/span\u003e]) \u003cspan class=\"hljs-comment\"\u003e# its return list is just integer\u003c/span\u003e\nreturn_types_get_const_val = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(return_types_get_const_val)) + return_types_get_const_val \u003cspan class=\"hljs-comment\"\u003e# prepend length (in encoded form) of the list to itself\u003c/span\u003e\n\nfunc_type_get_const_val = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x60\u003c/span\u003e]) + param_types_get_const_val + return_types_get_const_val\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eparam_types_add_two_nums = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x7f\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e0x7f\u003c/span\u003e]) \u003cspan class=\"hljs-comment\"\u003e# its parameter list is two integers\u003c/span\u003e\nparam_types_add_two_nums = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(param_types_add_two_nums)) + param_types_add_two_nums \u003cspan class=\"hljs-comment\"\u003e# prepend length (in encoded form) of the list to itself\u003c/span\u003e\n\nreturn_types_add_two_nums = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x7f\u003c/span\u003e]) \u003cspan class=\"hljs-comment\"\u003e# its return list is just integer\u003c/span\u003e\nreturn_types_add_two_nums = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(return_types_add_two_nums)) + return_types_add_two_nums \u003cspan class=\"hljs-comment\"\u003e# prepend length (in encoded form) of the list to itself\u003c/span\u003e\n\nfunc_type_add_two_nums = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x60\u003c/span\u003e]) + param_types_add_two_nums + return_types_add_two_nums\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eparam_types_call_functions = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([]) \u003cspan class=\"hljs-comment\"\u003e# its parameter list is empty\u003c/span\u003e\nparam_types_call_functions = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(param_types_call_functions)) + param_types_call_functions \u003cspan class=\"hljs-comment\"\u003e# prepend length (in encoded form) of the list to itself\u003c/span\u003e\n\nreturn_types_call_functions = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x7f\u003c/span\u003e]) \u003cspan class=\"hljs-comment\"\u003e# its return list is just integer\u003c/span\u003e\nreturn_types_call_functions = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(return_types_call_functions)) + return_types_call_functions \u003cspan class=\"hljs-comment\"\u003e# prepend length (in encoded form) of the list to itself\u003c/span\u003e\n\nfunc_type_call_functions = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x60\u003c/span\u003e]) + param_types_call_functions + return_types_call_functions\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eLet us now define our \u003ccode\u003etype\u003c/code\u003e section\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003efunc_types = [func_type_get_const_val, func_type_add_two_nums, func_type_call_functions] \u003cspan class=\"hljs-comment\"\u003e# take care to add these functions in proper order, as we will use indexes to refer them\u003c/span\u003e\n\ntype_section_id = leb128.u.encode(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# id of type section is 1\u003c/span\u003e\n\ntype_section_content = leb128.u.encode(\n    \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(func_types))  \u003cspan class=\"hljs-comment\"\u003e# first add length (in encoded form) and then\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e func_type \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e func_types: \u003cspan class=\"hljs-comment\"\u003e# add the contents of func_types\u003c/span\u003e\n    type_section_content.extend(func_type)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003etype_section = type_section_id + leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(type_section_content)) + type_section_content\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"function-section\"\u003eFunction Section\u003c/h3\u003e\n\u003cp\u003eSo, from the section name, it seems we will be defining our \u003ccode\u003efunctions\u003c/code\u003e\nin this section. From my understanding, we need to break our function\ndefinition into parts, the function prototype and the function body.\n(Yup, I know we already declared our function prototypes in the \u003ccode\u003etype\u003c/code\u003e\nsection)\u003c/p\u003e\n\u003cp\u003eHere, instead of redeclaring our \u003ccode\u003efunction types\u003c/code\u003e (or\n\u003ccode\u003efunction prototypes\u003c/code\u003e as I understand them), we will reference the\nalready defined \u003ccode\u003efunction type\u003c/code\u003e. That is we will just specify an index\nto the \u003ccode\u003efunction type\u003c/code\u003e that we wish to have for our \u003ccode\u003efunction\u003c/code\u003e.\u003c/p\u003e\n\u003cp\u003eThe next question that comes here is that\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eok, I referenced the \u003ccode\u003efunction type\u003c/code\u003e (lets say) at index \u003ccode\u003e0\u003c/code\u003e, where\ndo I write its \u003ccode\u003efunction body\u003c/code\u003e?\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003eans:\u003c/code\u003e As per the \u003ca href=\"https://webassembly.github.io/spec/core/binary/modules.html#binary-codesec\"\u003eWebAssembly\nDocs\u003c/a\u003e,\nit happens that, \u003ccode\u003efunction bodies\u003c/code\u003e (\u003ccode\u003elocal variables\u003c/code\u003e + \u003ccode\u003estatements\u003c/code\u003e are\nto be mentioned in the \u003ccode\u003ecode section\u003c/code\u003e).\u003c/p\u003e\n\u003cp\u003eSo, let's go ahead and reference the three declared \u003ccode\u003efunction types\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003etype_ids = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e])\n\nfunc_section_id = leb128.u.encode(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# id of function section is 3\u003c/span\u003e\nfunc_section_content = leb128.u.encode(\n    \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(type_ids)) \u003cspan class=\"hljs-comment\"\u003e# first add length (in encoded form) and then\u003c/span\u003e\nfunc_section_content += type_ids \u003cspan class=\"hljs-comment\"\u003e# add the contents of type_ids\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003efunc_section = func_section_id + leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(func_section_content)) + func_section_content\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3 id=\"code-section\"\u003eCode Section\u003c/h3\u003e\n\u003cp\u003eWe define our \u003ccode\u003efunction bodies\u003c/code\u003e (\u003ccode\u003elocal variables\u003c/code\u003e + \u003ccode\u003estatements\u003c/code\u003e) for\nour three functions (\u003ccode\u003eget_const_val\u003c/code\u003e, \u003ccode\u003eadd_two_nums\u003c/code\u003e, \u003ccode\u003ecall_functions\u003c/code\u003e)\nin this section.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003elocal_vars_get_const_val = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([]) \u003cspan class=\"hljs-comment\"\u003e# it does not contain any local variables\u003c/span\u003e\nlocal_vars_get_const_val = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(local_vars_get_const_val)) + local_vars_get_const_val\n\ninstructions_get_const_val_1 = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x41\u003c/span\u003e]) + leb128.i.encode(-\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# it contains just one instruction\u003c/span\u003e\n\nexpr_get_const_val = instructions_get_const_val_1 + \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x0b\u003c/span\u003e]) \u003cspan class=\"hljs-comment\"\u003e# expression contains all instructions and it ends with byte 0x0b\u003c/span\u003e\n\nfunc_get_const_val = local_vars_get_const_val + expr_get_const_val\n\ncode_get_const_val = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(func_get_const_val)) + func_get_const_val\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003elocal_vars_add_two_nums = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([]) \u003cspan class=\"hljs-comment\"\u003e# it does not contain any local variables\u003c/span\u003e\nlocal_vars_add_two_nums = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(local_vars_add_two_nums)) + local_vars_add_two_nums\n\ninstructions_add_two_nums_1 = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x20\u003c/span\u003e]) + leb128.u.encode(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# get parameter 0\u003c/span\u003e\ninstructions_add_two_nums_2 = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x20\u003c/span\u003e]) + leb128.u.encode(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# get parameter 1\u003c/span\u003e\ninstructions_add_two_nums_3 = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x6a\u003c/span\u003e]) \u003cspan class=\"hljs-comment\"\u003e# add the two operands on the stack\u003c/span\u003e\n\nexpr_add_two_nums = instructions_add_two_nums_1 + instructions_add_two_nums_2 + instructions_add_two_nums_3 + \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x0b\u003c/span\u003e]) \u003cspan class=\"hljs-comment\"\u003e# expression contains all instructions and it ends with byte 0x0b\u003c/span\u003e\n\nfunc_add_two_nums = local_vars_add_two_nums + expr_add_two_nums\n\ncode_add_two_nums = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(func_add_two_nums)) + func_add_two_nums\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003elocal_vars_call_functions = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([]) \u003cspan class=\"hljs-comment\"\u003e# it does not contain any local variables\u003c/span\u003e\nlocal_vars_call_functions = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(local_vars_call_functions)) + local_vars_call_functions\n\ninstructions_call_functions_1 = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e]) + leb128.u.encode(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# call function get_const_val\u003c/span\u003e\ninstructions_call_functions_2 = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e]) + leb128.u.encode(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# call function get_const_val\u003c/span\u003e\ninstructions_call_functions_3 = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x10\u003c/span\u003e]) + leb128.u.encode(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# call function call_functions and pass the two values on the stack, that is (-10, -10)\u003c/span\u003e\n\nexpr_call_functions = instructions_call_functions_1 + instructions_call_functions_2 + instructions_call_functions_3 + \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x0b\u003c/span\u003e]) \u003cspan class=\"hljs-comment\"\u003e# expression contains all instructions and it ends with byte 0x0b\u003c/span\u003e\n\nfunc_call_functions = local_vars_call_functions + expr_call_functions\n\ncode_call_functions = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(func_call_functions)) + func_call_functions\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003ecodes = [code_get_const_val, code_add_two_nums, code_call_functions]\n\ncode_section_id = leb128.u.encode(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# id of code section is 10\u003c/span\u003e\ncode_section_content = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(codes)) \u003cspan class=\"hljs-comment\"\u003e# first add length (in encoded form) and then\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e code \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e codes: \u003cspan class=\"hljs-comment\"\u003e# add the contents of codes\u003c/span\u003e\n    code_section_content.extend(code)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003ecode_section = code_section_id + leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(code_section_content)) + code_section_content\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003ePlease, note here that, the number of \u003ccode\u003etypes referenced\u003c/code\u003e and the number\nof \u003ccode\u003efunction bodies\u003c/code\u003e defined must match.\u003c/p\u003e\n\u003ch3 id=\"export-section\"\u003eExport Section\u003c/h3\u003e\n\u003cp\u003eNow, we need to export our three functions (\u003ccode\u003eget_const_val\u003c/code\u003e,\n\u003ccode\u003eadd_two_nums\u003c/code\u003e, \u003ccode\u003ecall_functions\u003c/code\u003e), so that we can use them in\n\u003ccode\u003eJavaScript\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003ename_get_const_val = \u003cspan class=\"hljs-string\"\u003e\"get_const_val\"\u003c/span\u003e.encode(encoding=\u003cspan class=\"hljs-string\"\u003e\"utf-8\"\u003c/span\u003e)\nname_get_const_val = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(name_get_const_val)) + \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e(name_get_const_val) \u003cspan class=\"hljs-comment\"\u003e# add length (in encoded form) followed by the encoded name string\u003c/span\u003e\n\nexport_desc_get_const_val = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x00\u003c/span\u003e]) + leb128.u.encode(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# encoding function index\u003c/span\u003e\n\nexport_get_const_val = name_get_const_val + export_desc_get_const_val\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003ename_add_two_nums = \u003cspan class=\"hljs-string\"\u003e\"add_two_nums\"\u003c/span\u003e.encode(encoding=\u003cspan class=\"hljs-string\"\u003e\"utf-8\"\u003c/span\u003e)\nname_add_two_nums = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(name_add_two_nums)) + \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e(name_add_two_nums) \u003cspan class=\"hljs-comment\"\u003e# add length (in encoded form) followed by the encoded name string\u003c/span\u003e\n\nexport_desc_add_two_nums = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x00\u003c/span\u003e]) + leb128.u.encode(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# encoding function index\u003c/span\u003e\n\nexport_add_two_nums = name_add_two_nums + export_desc_add_two_nums\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003ename_call_functions = \u003cspan class=\"hljs-string\"\u003e\"call_functions\"\u003c/span\u003e.encode(encoding=\u003cspan class=\"hljs-string\"\u003e\"utf-8\"\u003c/span\u003e)\nname_call_functions = leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(name_call_functions)) + \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e(name_call_functions) \u003cspan class=\"hljs-comment\"\u003e# add length (in encoded form) followed by the encoded name string\u003c/span\u003e\n\nexport_desc_call_functions = \u003cspan class=\"hljs-built_in\"\u003ebytearray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e0x00\u003c/span\u003e]) + leb128.u.encode(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e)  \u003cspan class=\"hljs-comment\"\u003e# encoding function index\u003c/span\u003e\n\nexport_call_functions = name_call_functions + export_desc_call_functions\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eexports = [export_get_const_val, export_add_two_nums, export_call_functions]\n\nexport_section_id = leb128.u.encode(\u003cspan class=\"hljs-number\"\u003e7\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e# id of export section is 10\u003c/span\u003e\nexport_section_content = leb128.u.encode(\n    \u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(exports)) \u003cspan class=\"hljs-comment\"\u003e# first add length (in encoded form) and then\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e export \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e exports: \u003cspan class=\"hljs-comment\"\u003e# add the contents of exports\u003c/span\u003e\n    export_section_content.extend(export)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eexport_section = export_section_id + leb128.u.encode(\u003cspan class=\"hljs-built_in\"\u003elen\u003c/span\u003e(export_section_content)) + export_section_content\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"creating-the-final-testwasm\"\u003eCreating the final \u003ccode\u003etest.wasm\u003c/code\u003e\u003c/h2\u003e\n\u003cp\u003eWe combine all the above sections in the increasing order of section\nIds. Incorrect order leads to inconsitent wasm module.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eall_code = module + version + type_section + func_section + export_section + code_section\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, we write our \u003ccode\u003eall_code\u003c/code\u003e to \u003ccode\u003ebinary file\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-keyword\"\u003ewith\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\"test.wasm\"\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\"wb\"\u003c/span\u003e) \u003cspan class=\"hljs-keyword\"\u003eas\u003c/span\u003e wasm_file:\n    wasm_file.write(\u003cspan class=\"hljs-built_in\"\u003ebytes\u003c/span\u003e(all_code))\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch1 id=\"testing-time\"\u003eTesting Time!\u003c/h1\u003e\n\u003cp\u003eLet use first test our functions defined in \u003ccode\u003epython\u003c/code\u003e\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(get_const_val())\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(add_two_nums(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e))\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(call_functions())\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e-10\n9\n-20\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eNow, to test our \u003ccode\u003ewasm\u003c/code\u003e functions, we need to import them in\n\u003ccode\u003eJavaScript\u003c/code\u003e and the call them (the code for the same in given in\n\u003ccode\u003eAppendix\u003c/code\u003e at the end). Since, it seems that Google Colab supports only\nclient side JavaScript and does not support node.js, here, we can\ncurrently (temporarily) use pywasm (which provides the WebAssembly\nruntime for python) to test the exported function.\u003c/p\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003eruntime = pywasm.load(\u003cspan class=\"hljs-string\"\u003e'./test.wasm'\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-python\"\u003e\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(runtime.\u003cspan class=\"hljs-built_in\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'get_const_val'\u003c/span\u003e, []))\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(runtime.\u003cspan class=\"hljs-built_in\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'add_two_nums'\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e]))\n\u003cspan class=\"hljs-built_in\"\u003eprint\u003c/span\u003e(runtime.\u003cspan class=\"hljs-built_in\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'call_functions'\u003c/span\u003e, []))\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre\u003e\u003ccode\u003e-10\n9\n-20\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2 id=\"appendix\"\u003eAppendix\u003c/h2\u003e\n\u003cpre\u003e\u003ccode class=\"hljs language-javascript\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fs = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'fs'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e wasmBuffer = fs.\u003cspan class=\"hljs-title function_\"\u003ereadFileSync\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e'./test.wasm'\u003c/span\u003e);\n\n\u003cspan class=\"hljs-title class_\"\u003eWebAssembly\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003einstantiate\u003c/span\u003e(wasmBuffer).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003ewasmModule\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// Exported function live under instance.exports\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e get_const_val = wasmModule.\u003cspan class=\"hljs-property\"\u003einstance\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eget_const_val\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e add_two_nums = wasmModule.\u003cspan class=\"hljs-property\"\u003einstance\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eadd_two_nums\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e call_functions = wasmModule.\u003cspan class=\"hljs-property\"\u003einstance\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecall_functions\u003c/span\u003e;\n    \n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eget_const_val\u003c/span\u003e());\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eadd_two_nums\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e));\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003ecall_functions\u003c/span\u003e())\n});\n\u003c/code\u003e\u003c/pre\u003e\n","frontmatter":{"slug":"misc_1_wasm_binary_experimentation","excerpt":"Let us write a script which writes wasm ...","title":"Wasm Binary Internals Demystified","publishedAt":"2022-05-01","day":"May 1, 2022","readingTime":"9 min read"}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"misc_1_wasm_binary_experimentation"},"buildId":"2ii59PcnJFayGOASnop7S","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>