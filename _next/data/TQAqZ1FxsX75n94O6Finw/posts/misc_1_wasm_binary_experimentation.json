{"pageProps":{"blog":{"content":"<h1 id=\"wasm-binary-experimentation\">WASM Binary Experimentation</h1>\n<p>In this notebook, let us write a <code>python</code> script which writes <code>wasm</code>\nbinary. (Yup, you read it right, writing a script that writes another\nscript, ðŸ˜Ž)</p>\n<p>For example, let us aim to write the following <code>WAT</code> in <code>wasm</code> binary\nusing our <code>python</code> script.</p>\n<pre><code>(module\n  (func (export \"get_const_val\") (result i32)\n    i32.const -10)\n  (func (export \"add_two_nums\") (param i32 i32) (result i32)\n    local.get 0\n    local.get 1\n    i32.add)\n  (func (export \"call_functions\") (result i32)\n    call 0\n    call 0\n    call 1)\n)\n</code></pre>\n<ul>\n<li>The function <code>get_const_val</code> returns a constant value of <code>-10</code>.</li>\n<li>The function <code>add_two_nums</code> adds the given numbers and returns the\nresult of addition.</li>\n<li>The function <code>call_functions</code> calls <code>get_const_val</code> twice and then\ncalls <code>add_two_nums</code>. Please note here that we used the indexes of\nthe <code>get_const_val</code> and <code>add_two_nums</code> when calling them.</li>\n</ul>\n<p>In python, the implementation of these functions would be as follows:</p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_const_val</span>():\n  <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_two_nums</span>(<span class=\"hljs-params\">a, b</span>): <span class=\"hljs-comment\"># in the WAT format, we did not give names, instead we used indexes to refer to the parameters</span>\n  <span class=\"hljs-keyword\">return</span> a + b\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">call_functions</span>():\n  <span class=\"hljs-keyword\">return</span> add_two_nums(get_const_val(), get_const_val())\n</code></pre>\n<p>Our <code>python</code> script starts from the following sections.</p>\n<p><strong>Let's dive in!!!</strong></p>\n<h2 id=\"importing-required-modules\">Importing required modules</h2>\n<p><code>wasm</code> expects integers to be in <code>leb128</code> (Little Endian Base 128)\nformat. So, we use the following library/module to encode the <code>integers</code>\n(<code>signed</code> as well as <code>unsigned</code>). Also, from my experience, <code>index</code> of\nvariables/functions are being considered to be <code>integers</code> and therefore\nneed to be encoded.</p>\n<pre><code class=\"hljs language-python\">!pip install leb128\n<span class=\"hljs-keyword\">import</span> leb128\n</code></pre>\n<pre><code>Requirement already satisfied: leb128 in /usr/local/lib/python3.7/dist-packages (1.0.4)\n</code></pre>\n<p>To test the generated <code>test.wasm</code> we need to import the <code>wasm</code> exported\nfunctions in <code>JavaScript</code>/<code>node.js</code>. Since, it seems that <code>Google Colab</code>\nsupports only <code>client</code> side <code>JavaScript</code> and does not support <code>node.js</code>,\nhere, we can currently (temporarily) use <code>pywasm</code> (which provides the\n<code>WebAssembly</code> runtime for <code>python</code>) to test the exported function.</p>\n<pre><code class=\"hljs language-python\">!pip install pywasm\n<span class=\"hljs-keyword\">import</span> pywasm\n</code></pre>\n<pre><code>Requirement already satisfied: pywasm in /usr/local/lib/python3.7/dist-packages (1.0.7)\nRequirement already satisfied: numpy in /usr/local/lib/python3.7/dist-packages (from pywasm) (1.21.6)\n</code></pre>\n<h2 id=\"generating-the-testwasm-binary\">Generating the <code>test.wasm</code> binary</h2>\n<p>A <code>wasm</code> binary starts with <code>module</code> and <code>version</code></p>\n<p>here:</p>\n<ul>\n<li><code>module</code> = \"\\0asm\"</li>\n<li><code>version</code> = 1</li>\n</ul>\n<pre><code class=\"hljs language-python\">module = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x00</span>, <span class=\"hljs-number\">0x61</span>, <span class=\"hljs-number\">0x73</span>, <span class=\"hljs-number\">0x6d</span>])\nversion = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x01</span>, <span class=\"hljs-number\">0x00</span>, <span class=\"hljs-number\">0x00</span>, <span class=\"hljs-number\">0x00</span>])\n</code></pre>\n<p><code>wasm</code> binary consists of the following sections. These sections come\nafter the <code>mdoule</code> and <code>version</code>.</p>\n<p>  Id   Section</p>\n<hr>\n<p>  0    custom section\n  1    type section\n  2    import section\n  3    function section\n  4    table section\n  5    memory section\n  6    global section\n  7    export section\n  8    start section\n  9    element section\n  10   code section\n  11   data section\n  12   data count section</p>\n<p>Each section consists of</p>\n<ul>\n<li>a one-byte section id,</li>\n<li>the size of the contents, in bytes,</li>\n<li>the actual contents, whose structure is depended on the section id.</li>\n</ul>\n<p>These sections can either be omitted or can be present atmost once.\nAlso, these sections need to be present in the specific order.</p>\n<p>Let us define the sections we need in the following cells.</p>\n<h3 id=\"type-section\">Type Section</h3>\n<p>From my understanding, this section is used to declare <code>function type</code>\nthat is <code>function signature</code> (I assume this to be similar to\n<code>function declaration</code> or <code>function prototyping</code> in <code>C</code>/<code>C++</code>)</p>\n<p>Let's define the functions types for our three functions\n(<code>get_const_val</code>, <code>add_two_nums</code>, <code>call_functions</code>) one by one</p>\n<pre><code class=\"hljs language-python\">param_types_get_const_val = <span class=\"hljs-built_in\">bytearray</span>([]) <span class=\"hljs-comment\"># its parameter list is empty</span>\nparam_types_get_const_val = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(param_types_get_const_val)) + param_types_get_const_val <span class=\"hljs-comment\"># prepend length (in encoded form) of the list to itself</span>\n\nreturn_types_get_const_val = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x7f</span>]) <span class=\"hljs-comment\"># its return list is just integer</span>\nreturn_types_get_const_val = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(return_types_get_const_val)) + return_types_get_const_val <span class=\"hljs-comment\"># prepend length (in encoded form) of the list to itself</span>\n\nfunc_type_get_const_val = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x60</span>]) + param_types_get_const_val + return_types_get_const_val\n</code></pre>\n<pre><code class=\"hljs language-python\">param_types_add_two_nums = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x7f</span>, <span class=\"hljs-number\">0x7f</span>]) <span class=\"hljs-comment\"># its parameter list is two integers</span>\nparam_types_add_two_nums = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(param_types_add_two_nums)) + param_types_add_two_nums <span class=\"hljs-comment\"># prepend length (in encoded form) of the list to itself</span>\n\nreturn_types_add_two_nums = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x7f</span>]) <span class=\"hljs-comment\"># its return list is just integer</span>\nreturn_types_add_two_nums = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(return_types_add_two_nums)) + return_types_add_two_nums <span class=\"hljs-comment\"># prepend length (in encoded form) of the list to itself</span>\n\nfunc_type_add_two_nums = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x60</span>]) + param_types_add_two_nums + return_types_add_two_nums\n</code></pre>\n<pre><code class=\"hljs language-python\">param_types_call_functions = <span class=\"hljs-built_in\">bytearray</span>([]) <span class=\"hljs-comment\"># its parameter list is empty</span>\nparam_types_call_functions = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(param_types_call_functions)) + param_types_call_functions <span class=\"hljs-comment\"># prepend length (in encoded form) of the list to itself</span>\n\nreturn_types_call_functions = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x7f</span>]) <span class=\"hljs-comment\"># its return list is just integer</span>\nreturn_types_call_functions = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(return_types_call_functions)) + return_types_call_functions <span class=\"hljs-comment\"># prepend length (in encoded form) of the list to itself</span>\n\nfunc_type_call_functions = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x60</span>]) + param_types_call_functions + return_types_call_functions\n</code></pre>\n<p>Let us now define our <code>type</code> section</p>\n<pre><code class=\"hljs language-python\">func_types = [func_type_get_const_val, func_type_add_two_nums, func_type_call_functions] <span class=\"hljs-comment\"># take care to add these functions in proper order, as we will use indexes to refer them</span>\n\ntype_section_id = leb128.u.encode(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\"># id of type section is 1</span>\n\ntype_section_content = leb128.u.encode(\n    <span class=\"hljs-built_in\">len</span>(func_types))  <span class=\"hljs-comment\"># first add length (in encoded form) and then</span>\n<span class=\"hljs-keyword\">for</span> func_type <span class=\"hljs-keyword\">in</span> func_types: <span class=\"hljs-comment\"># add the contents of func_types</span>\n    type_section_content.extend(func_type)\n</code></pre>\n<pre><code class=\"hljs language-python\">type_section = type_section_id + leb128.u.encode(<span class=\"hljs-built_in\">len</span>(type_section_content)) + type_section_content\n</code></pre>\n<h3 id=\"function-section\">Function Section</h3>\n<p>So, from the section name, it seems we will be defining our <code>functions</code>\nin this section. From my understanding, we need to break our function\ndefinition into parts, the function prototype and the function body.\n(Yup, I know we already declared our function prototypes in the <code>type</code>\nsection)</p>\n<p>Here, instead of redeclaring our <code>function types</code> (or\n<code>function prototypes</code> as I understand them), we will reference the\nalready defined <code>function type</code>. That is we will just specify an index\nto the <code>function type</code> that we wish to have for our <code>function</code>.</p>\n<p>The next question that comes here is that</p>\n<ul>\n<li>ok, I referenced the <code>function type</code> (lets say) at index <code>0</code>, where\ndo I write its <code>function body</code>?</li>\n</ul>\n<p><code>ans:</code> As per the <a href=\"https://webassembly.github.io/spec/core/binary/modules.html#binary-codesec\">WebAssembly\nDocs</a>,\nit happens that, <code>function bodies</code> (<code>local variables</code> + <code>statements</code> are\nto be mentioned in the <code>code section</code>).</p>\n<p>So, let's go ahead and reference the three declared <code>function types</code></p>\n<pre><code class=\"hljs language-python\">type_ids = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>])\n\nfunc_section_id = leb128.u.encode(<span class=\"hljs-number\">3</span>)  <span class=\"hljs-comment\"># id of function section is 3</span>\nfunc_section_content = leb128.u.encode(\n    <span class=\"hljs-built_in\">len</span>(type_ids)) <span class=\"hljs-comment\"># first add length (in encoded form) and then</span>\nfunc_section_content += type_ids <span class=\"hljs-comment\"># add the contents of type_ids</span>\n</code></pre>\n<pre><code class=\"hljs language-python\">func_section = func_section_id + leb128.u.encode(<span class=\"hljs-built_in\">len</span>(func_section_content)) + func_section_content\n</code></pre>\n<h3 id=\"code-section\">Code Section</h3>\n<p>We define our <code>function bodies</code> (<code>local variables</code> + <code>statements</code>) for\nour three functions (<code>get_const_val</code>, <code>add_two_nums</code>, <code>call_functions</code>)\nin this section.</p>\n<pre><code class=\"hljs language-python\">local_vars_get_const_val = <span class=\"hljs-built_in\">bytearray</span>([]) <span class=\"hljs-comment\"># it does not contain any local variables</span>\nlocal_vars_get_const_val = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(local_vars_get_const_val)) + local_vars_get_const_val\n\ninstructions_get_const_val_1 = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x41</span>]) + leb128.i.encode(-<span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\"># it contains just one instruction</span>\n\nexpr_get_const_val = instructions_get_const_val_1 + <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x0b</span>]) <span class=\"hljs-comment\"># expression contains all instructions and it ends with byte 0x0b</span>\n\nfunc_get_const_val = local_vars_get_const_val + expr_get_const_val\n\ncode_get_const_val = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(func_get_const_val)) + func_get_const_val\n</code></pre>\n<pre><code class=\"hljs language-python\">local_vars_add_two_nums = <span class=\"hljs-built_in\">bytearray</span>([]) <span class=\"hljs-comment\"># it does not contain any local variables</span>\nlocal_vars_add_two_nums = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(local_vars_add_two_nums)) + local_vars_add_two_nums\n\ninstructions_add_two_nums_1 = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x20</span>]) + leb128.u.encode(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\"># get parameter 0</span>\ninstructions_add_two_nums_2 = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x20</span>]) + leb128.u.encode(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\"># get parameter 1</span>\ninstructions_add_two_nums_3 = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x6a</span>]) <span class=\"hljs-comment\"># add the two operands on the stack</span>\n\nexpr_add_two_nums = instructions_add_two_nums_1 + instructions_add_two_nums_2 + instructions_add_two_nums_3 + <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x0b</span>]) <span class=\"hljs-comment\"># expression contains all instructions and it ends with byte 0x0b</span>\n\nfunc_add_two_nums = local_vars_add_two_nums + expr_add_two_nums\n\ncode_add_two_nums = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(func_add_two_nums)) + func_add_two_nums\n</code></pre>\n<pre><code class=\"hljs language-python\">local_vars_call_functions = <span class=\"hljs-built_in\">bytearray</span>([]) <span class=\"hljs-comment\"># it does not contain any local variables</span>\nlocal_vars_call_functions = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(local_vars_call_functions)) + local_vars_call_functions\n\ninstructions_call_functions_1 = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x10</span>]) + leb128.u.encode(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\"># call function get_const_val</span>\ninstructions_call_functions_2 = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x10</span>]) + leb128.u.encode(<span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\"># call function get_const_val</span>\ninstructions_call_functions_3 = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x10</span>]) + leb128.u.encode(<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\"># call function call_functions and pass the two values on the stack, that is (-10, -10)</span>\n\nexpr_call_functions = instructions_call_functions_1 + instructions_call_functions_2 + instructions_call_functions_3 + <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x0b</span>]) <span class=\"hljs-comment\"># expression contains all instructions and it ends with byte 0x0b</span>\n\nfunc_call_functions = local_vars_call_functions + expr_call_functions\n\ncode_call_functions = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(func_call_functions)) + func_call_functions\n</code></pre>\n<pre><code class=\"hljs language-python\">codes = [code_get_const_val, code_add_two_nums, code_call_functions]\n\ncode_section_id = leb128.u.encode(<span class=\"hljs-number\">10</span>) <span class=\"hljs-comment\"># id of code section is 10</span>\ncode_section_content = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(codes)) <span class=\"hljs-comment\"># first add length (in encoded form) and then</span>\n<span class=\"hljs-keyword\">for</span> code <span class=\"hljs-keyword\">in</span> codes: <span class=\"hljs-comment\"># add the contents of codes</span>\n    code_section_content.extend(code)\n</code></pre>\n<pre><code class=\"hljs language-python\">code_section = code_section_id + leb128.u.encode(<span class=\"hljs-built_in\">len</span>(code_section_content)) + code_section_content\n</code></pre>\n<p>Please, note here that, the number of <code>types referenced</code> and the number\nof <code>function bodies</code> defined must match.</p>\n<h3 id=\"export-section\">Export Section</h3>\n<p>Now, we need to export our three functions (<code>get_const_val</code>,\n<code>add_two_nums</code>, <code>call_functions</code>), so that we can use them in\n<code>JavaScript</code></p>\n<pre><code class=\"hljs language-python\">name_get_const_val = <span class=\"hljs-string\">\"get_const_val\"</span>.encode(encoding=<span class=\"hljs-string\">\"utf-8\"</span>)\nname_get_const_val = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(name_get_const_val)) + <span class=\"hljs-built_in\">bytearray</span>(name_get_const_val) <span class=\"hljs-comment\"># add length (in encoded form) followed by the encoded name string</span>\n\nexport_desc_get_const_val = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x00</span>]) + leb128.u.encode(<span class=\"hljs-number\">0</span>)  <span class=\"hljs-comment\"># encoding function index</span>\n\nexport_get_const_val = name_get_const_val + export_desc_get_const_val\n</code></pre>\n<pre><code class=\"hljs language-python\">name_add_two_nums = <span class=\"hljs-string\">\"add_two_nums\"</span>.encode(encoding=<span class=\"hljs-string\">\"utf-8\"</span>)\nname_add_two_nums = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(name_add_two_nums)) + <span class=\"hljs-built_in\">bytearray</span>(name_add_two_nums) <span class=\"hljs-comment\"># add length (in encoded form) followed by the encoded name string</span>\n\nexport_desc_add_two_nums = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x00</span>]) + leb128.u.encode(<span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\"># encoding function index</span>\n\nexport_add_two_nums = name_add_two_nums + export_desc_add_two_nums\n</code></pre>\n<pre><code class=\"hljs language-python\">name_call_functions = <span class=\"hljs-string\">\"call_functions\"</span>.encode(encoding=<span class=\"hljs-string\">\"utf-8\"</span>)\nname_call_functions = leb128.u.encode(<span class=\"hljs-built_in\">len</span>(name_call_functions)) + <span class=\"hljs-built_in\">bytearray</span>(name_call_functions) <span class=\"hljs-comment\"># add length (in encoded form) followed by the encoded name string</span>\n\nexport_desc_call_functions = <span class=\"hljs-built_in\">bytearray</span>([<span class=\"hljs-number\">0x00</span>]) + leb128.u.encode(<span class=\"hljs-number\">2</span>)  <span class=\"hljs-comment\"># encoding function index</span>\n\nexport_call_functions = name_call_functions + export_desc_call_functions\n</code></pre>\n<pre><code class=\"hljs language-python\">exports = [export_get_const_val, export_add_two_nums, export_call_functions]\n\nexport_section_id = leb128.u.encode(<span class=\"hljs-number\">7</span>) <span class=\"hljs-comment\"># id of export section is 10</span>\nexport_section_content = leb128.u.encode(\n    <span class=\"hljs-built_in\">len</span>(exports)) <span class=\"hljs-comment\"># first add length (in encoded form) and then</span>\n<span class=\"hljs-keyword\">for</span> export <span class=\"hljs-keyword\">in</span> exports: <span class=\"hljs-comment\"># add the contents of exports</span>\n    export_section_content.extend(export)\n</code></pre>\n<pre><code class=\"hljs language-python\">export_section = export_section_id + leb128.u.encode(<span class=\"hljs-built_in\">len</span>(export_section_content)) + export_section_content\n</code></pre>\n<h2 id=\"creating-the-final-testwasm\">Creating the final <code>test.wasm</code></h2>\n<p>We combine all the above sections in the increasing order of section\nIds. Incorrect order leads to inconsitent wasm module.</p>\n<pre><code class=\"hljs language-python\">all_code = module + version + type_section + func_section + export_section + code_section\n</code></pre>\n<p>Now, we write our <code>all_code</code> to <code>binary file</code></p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-keyword\">with</span> <span class=\"hljs-built_in\">open</span>(<span class=\"hljs-string\">\"test.wasm\"</span>, <span class=\"hljs-string\">\"wb\"</span>) <span class=\"hljs-keyword\">as</span> wasm_file:\n    wasm_file.write(<span class=\"hljs-built_in\">bytes</span>(all_code))\n</code></pre>\n<h1 id=\"testing-time\">Testing Time!</h1>\n<p>Let use first test our functions defined in <code>python</code></p>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-built_in\">print</span>(get_const_val())\n<span class=\"hljs-built_in\">print</span>(add_two_nums(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>))\n<span class=\"hljs-built_in\">print</span>(call_functions())\n</code></pre>\n<pre><code>-10\n9\n-20\n</code></pre>\n<p>Now, to test our <code>wasm</code> functions, we need to import them in\n<code>JavaScript</code> and the call them (the code for the same in given in\n<code>Appendix</code> at the end). Since, it seems that Google Colab supports only\nclient side JavaScript and does not support node.js, here, we can\ncurrently (temporarily) use pywasm (which provides the WebAssembly\nruntime for python) to test the exported function.</p>\n<pre><code class=\"hljs language-python\">runtime = pywasm.load(<span class=\"hljs-string\">'./test.wasm'</span>)\n</code></pre>\n<pre><code class=\"hljs language-python\"><span class=\"hljs-built_in\">print</span>(runtime.<span class=\"hljs-built_in\">exec</span>(<span class=\"hljs-string\">'get_const_val'</span>, []))\n<span class=\"hljs-built_in\">print</span>(runtime.<span class=\"hljs-built_in\">exec</span>(<span class=\"hljs-string\">'add_two_nums'</span>, [<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>]))\n<span class=\"hljs-built_in\">print</span>(runtime.<span class=\"hljs-built_in\">exec</span>(<span class=\"hljs-string\">'call_functions'</span>, []))\n</code></pre>\n<pre><code>-10\n9\n-20\n</code></pre>\n<h2 id=\"appendix\">Appendix</h2>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">const</span> fs = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'fs'</span>);\n\n<span class=\"hljs-keyword\">const</span> wasmBuffer = fs.<span class=\"hljs-title function_\">readFileSync</span>(<span class=\"hljs-string\">'./test.wasm'</span>);\n\n<span class=\"hljs-title class_\">WebAssembly</span>.<span class=\"hljs-title function_\">instantiate</span>(wasmBuffer).<span class=\"hljs-title function_\">then</span>(<span class=\"hljs-function\"><span class=\"hljs-params\">wasmModule</span> =&gt;</span> {\n    <span class=\"hljs-comment\">// Exported function live under instance.exports</span>\n    <span class=\"hljs-keyword\">const</span> get_const_val = wasmModule.<span class=\"hljs-property\">instance</span>.<span class=\"hljs-property\">exports</span>.<span class=\"hljs-property\">get_const_val</span>;\n    <span class=\"hljs-keyword\">const</span> add_two_nums = wasmModule.<span class=\"hljs-property\">instance</span>.<span class=\"hljs-property\">exports</span>.<span class=\"hljs-property\">add_two_nums</span>;\n    <span class=\"hljs-keyword\">const</span> call_functions = wasmModule.<span class=\"hljs-property\">instance</span>.<span class=\"hljs-property\">exports</span>.<span class=\"hljs-property\">call_functions</span>;\n    \n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">get_const_val</span>());\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">add_two_nums</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>));\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-title function_\">call_functions</span>())\n});\n</code></pre>\n","frontmatter":{"slug":"misc_1_wasm_binary_experimentation","excerpt":"Let us write a script which writes wasm ...","title":"Wasm Binary Internals Demystified","publishedAt":"2022-05-01","day":"May 1, 2022","readingTime":"9 min read"}}},"__N_SSG":true}