{"pageProps":{"blog":{"content":"<h1 id=\"hey-there-ðŸ¤—-welcome-to-my-gsoc-journey\">Hey there ðŸ¤—, Welcome to my GSoC Journey</h1>\n<p>This is a series of blogs that I am writing to share my amazing <strong>GSoC 22</strong> (Google Summer of Code 2022) Journey with you all. </p>\n<hr>\n<h1 id=\"extending-wasm-and-wat-backends\">Extending WASM and WAT Backends</h1>\n<p>In this phase, I focused on extending the <code>WASM</code> and <code>WAT</code> Backends.\nSpecifically, I added support for </p>\n<ul>\n<li><code>i64</code> constants/literals</li>\n<li><code>unary minus</code> for <code>i32</code> and <code>i64</code></li>\n<li>floating points <code>f32</code> and <code>f64</code><ul>\n<li>constants/literals</li>\n<li>unary minus</li>\n<li>basic arithmetic operations</li>\n</ul>\n</li>\n</ul>\n<p>I also refactored the <code>WASM</code> and <code>WAT</code> Backends to hopefully improve them.</p>\n<p>A challenge I faced during this phase was during the decoding the <code>i64</code> constants in the <code>WASM-&gt;WAT</code> backend.\nI was following <a href=\"https://en.wikipedia.org/wiki/LEB128\">Wikipedia/LEB128</a> for the encoding and decoding of <code>u32</code> and <code>i32</code> constants.\nI followed the same for <code>i64</code> constants for encoding as well as decoding.\nEven after following the same/similar algorithm as given in <a href=\"https://en.wikipedia.org/wiki/LEB128\">Wikipedia/LEB128</a>,\nthe decoding was still not working correctly.\nAfter much research, I found <a href=\"https://llvm.org/doxygen/LEB128_8h_source.html\">this</a> which helped me find out the bug.</p>\n<p>The bug was in the following code:</p>\n<pre><code class=\"hljs language-cpp\">byte = next byte in input;\nresult |= (byte &amp; <span class=\"hljs-number\">0x7f</span>) &lt;&lt; shift;\nshift += <span class=\"hljs-number\">7</span>;\n</code></pre>\n<p>We see that in the middle line in the above code, we have <code>(byte &amp; 0x7f) &lt;&lt; shift</code>.\nSince <code>byte</code> is of <code>8 bits</code> and <code>0x7f</code> is of <code>32 bits</code>, the result will be of <code>32 bits</code> and this is fine when <code>shift &lt; 32</code>.\nTherefore, this code works for <code>i32</code> and <code>u32</code>, \nbut did not work for <code>i64</code> as we might/would lose bits once the <code>shift</code> which might be <code>&gt;= 32</code> is applied .</p>\n<p>The following code fixes the above issue:</p>\n<pre><code class=\"hljs language-cpp\">byte = next byte in input;\n<span class=\"hljs-type\">uint64_t</span> slice = (byte &amp; <span class=\"hljs-number\">0x7f</span>);\nresult |= slice &lt;&lt; shift;\nshift += <span class=\"hljs-number\">7</span>;\n</code></pre>\n<p>This phase was mostly/approximately from <code>13-06-2022</code> to <code>17-06-2022</code>.</p>\n<p>The MRs during this phase are as follows:</p>\n<ul>\n<li><a href=\"https://gitlab.com/lfortran/lfortran/-/merge_requests/1787\">!1787</a></li>\n<li><a href=\"https://gitlab.com/lfortran/lfortran/-/merge_requests/1789\">!1789</a></li>\n<li><a href=\"https://gitlab.com/lfortran/lfortran/-/merge_requests/1791\">!1791</a></li>\n<li><a href=\"https://gitlab.com/lfortran/lfortran/-/merge_requests/1792\">!1792</a></li>\n<li><a href=\"https://gitlab.com/lfortran/lfortran/-/merge_requests/1793\">!1793</a></li>\n</ul>\n<hr>\n<p>That's all for this blog. Thank you for your time. We continue this series in the next blog.</p>\n","frontmatter":{"slug":"gsoc_3_extending_wasm_and_wat_backends","excerpt":"GSoC 22: Blog 3","title":"Extending WASM and WAT Backends","publishedAt":"2022-06-17","day":"June 17, 2022","readingTime":"2 min read"}}},"__N_SSG":true}